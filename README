Azure App Service – Production-like Reference Architecture (Terraform)
Overview

This repository contains a production-oriented Azure App Service setup, implemented entirely with Terraform and structured around reusable modules.

The goal of this project is not to provide a minimal demo, but to demonstrate how a realistic, enterprise-style web application platform can be built with a focus on:

safe deployments

environment parity

security by default

observability

infrastructure reproducibility

All resources are deployed into a staging environment, which is intentionally designed to behave like production. This allows testing architecture, deployment flow, and platform behavior before applying the same patterns to an actual production environment.

Architectural Principles

The project follows a few core principles that are common in real-world Azure platforms:

Production-like Staging

The staging environment is treated as a full reference environment, not a simplified test setup.
It includes both a production slot and a staging slot to validate zero-downtime deployment flows and slot swaps.

Secure by Design

The application is publicly accessible over HTTPS, as expected for most web services.

All data access is private:

Azure Blob Storage has public access disabled.

Access is provided through a Private Endpoint and Private DNS.

The application uses Managed Identity and RBAC instead of secrets.

Network traffic to dependent services stays inside Azure’s private network.

Deployment Safety

Code is deployed to the staging slot first.

Health checks and runtime validation are performed before swap.

Slot swap is used as an atomic, low-risk promotion mechanism.

Rollback is achieved through a reverse swap if needed.

Observability

Centralized logging and metrics are enabled via Azure Monitor and Log Analytics.

Application telemetry is sent to Application Insights.

Diagnostic settings are configured explicitly for both the web app and storage services.

Infrastructure Structure

The infrastructure is defined using Terraform modules, assembled in a single environment (staging) to represent a realistic deployment.

Key Components

Azure App Service (Linux, Python)

Deployment slots (production and staging)

Health checks and startup configuration

System-assigned Managed Identity

VNet integration

Azure Storage Account

Blob container

Private Endpoint

Private DNS integration

Public network access disabled

Networking

Virtual Network

Dedicated subnets for integration and private endpoints

Monitoring

Log Analytics Workspace

Application Insights

Diagnostic settings for platform services

Modular Design

The project is structured around reusable modules.
Azure Verified Modules (AVM) are used as a foundation and wrapped with an additional abstraction layer to:

enforce consistent defaults

simplify consumption

expose a clear and stable interface

make the setup reusable across environments and projects

The main configuration assembles these modules into a coherent platform rather than defining resources directly.

Environment Strategy

Only the staging environment is implemented in this repository.

This is intentional:

Staging acts as a reference implementation for architecture and deployment flow.

Production environments are typically restricted and not exposed in public repositories.

The same modules and patterns can be reused for production with different configuration values.

What This Project Demonstrates

How to structure Terraform code for real-world Azure platforms

How to build deployment-slot-based release flows

How to combine public application access with private data access

How to use Managed Identity instead of secrets

How to design Terraform modules for reuse and clarity

How to treat staging as a production-like environment

Intended Audience

This repository is intended for:

Cloud and platform engineers

DevOps engineers

Architects evaluating Azure App Service patterns

Recruiters and hiring managers reviewing real-world infrastructure work

It is not a step-by-step tutorial, but a reference implementation reflecting common enterprise practices.

Notes

The code focuses on infrastructure and platform behavior rather than application logic.

Some configurations are simplified for clarity, but the overall design mirrors production use cases.

The project intentionally highlights real platform challenges encountered during deployment and runtime, rather than hiding them behind abstractions.
